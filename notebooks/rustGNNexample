use ndarray::{Array1, Array2};
use tch::{nn, Tensor};

struct MoleculeGNN {
    conv1: nn::Conv2D,
    conv2: nn::Conv2D,
    fc: nn::Linear,
}

impl MoleculeGNN {
    fn new(num_features: i64, hidden_size: i64, num_classes: i64, device: &Device) -> MoleculeGNN {
        let conv1 = nn::Conv2D::new(
            &nn::Conv2DConfig::default()
                .stride(1)
                .padding(0)
                .bias(false)
                .output_channels(hidden_size),
            device,
        );
        let conv2 = nn::Conv2D::new(
            &nn::Conv2DConfig::default()
                .stride(1)
                .padding(0)
                .bias(false)
                .output_channels(hidden_size),
            device,
        );
        let fc = nn::Linear::new(
            hidden_size,
            num_classes,
            Default::default(),
        );

        MoleculeGNN {
            conv1,
            conv2,
            fc,
        }
    }

    fn forward(&self, x: &Tensor, adj: &Tensor) -> Tensor {
        let x = self.conv1(x);
        let x = x.matmul(adj);
        let x = self.conv2(x);
        let x = x.sum_dim_intlist(&[2]);
        let x = self.fc(x);

        x.log_softmax(-1, Kind::Double)
    }
}
