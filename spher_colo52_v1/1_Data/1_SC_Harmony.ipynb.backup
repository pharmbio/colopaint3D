{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'/share/data/analyses/christa/colopaint3D/spher_colo52_v1/1_Data'"
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import os\n",
    "import pandas as pd \n",
    "# import polars as pl # like pandas, but much faster\n",
    "# import polars.selectors as cs\n",
    "import numpy as np\n",
    "import os, shutil, glob\n",
    "# from random import randint\n",
    "import re, math\n",
    "# from pathlib import Path\n",
    "\n",
    "\n",
    "os.getcwd()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def list_features(df):\n",
    "    return [c for c in df.columns if not c.startswith(\"Metadata\")]\n",
    "\n",
    "def list_metadata(df):\n",
    "    return [c for c in df.columns if c.startswith(\"Metadata\")]\n",
    "\n",
    "def get_featuredata(df):\n",
    "    \"\"\"Return DataFrame of numeric, non-metadata feature columns.\"\"\"\n",
    "    feature_cols = list_features(df)\n",
    "    assert all(np.issubdtype(df[c].dtype, np.number) for c in feature_cols), \\\n",
    "        \"Non-numeric columns found in feature data\"\n",
    "    return df[feature_cols]\n",
    "\n",
    "def get_metadata(df):\n",
    "    return df[list_metadata(df)]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Read data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "DataSingleCell =  pd.read_parquet(\"/home/jovyan/share/data/analyses/christa/colopaint3D/spher_colo52_v1/1_Data/FeaturesImages_291025_none/SingleCell/HCT116.parquet\") "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "### The plan \n",
    "\n",
    "# CONTEXT: Technical artifact from imaging depth (z-plane) creates variation that overshadows\n",
    "# biological variation from radial distance (spheroid outer→inner layers).\n",
    "# In center z-planes, we can see radial biology within a single plane.\n",
    "\n",
    "# PLAN A (full dataset):\n",
    "# 0) Make sure to keep track of metadata on the X,Y,Z location of each cell in the 3D image stack. \n",
    "#    Location_Center_X\n",
    "#    Location_Center_Y\n",
    "#    Location_Center_Z\n",
    "#    - Compute radial distance from spheroid center for each cell\n",
    "# 1) Squeeze the metadata into the index of the dataframe.\n",
    "# 2) Harmony integration using z-plane as batch covariate to remove technical depth artifacts\n",
    "#    - Test on DMSO controls first to verify it reveals radial biology\n",
    "# 3) Assign each cell to a cluster (Leiden clustering), just do it for a handful of dmso controls first.\n",
    "# 4) Check if clusters correspond to different layers of the 3D cell culture (radial distance from center)\n",
    "# 5) aggregate single cell data to spheroid layer level (mean or median feature values per layer)\n",
    "# 6) continue preprocessing and clustering at the spheroid layer level.\n",
    "\n",
    "# PLAN B (fallback if Harmony removes too much biology):\n",
    "# Focus analysis only on central z-planes where technical and biological signals are less confounded.\n",
    "# This avoids the confounding issue at top/bottom planes where radial distance ≈ z-plane position.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# ## Original harmony code snippet: \n",
    "# df_toharmonize = for_harmony.copy()\n",
    "\n",
    "\n",
    "# # Select the data for PCA\n",
    "# training_data = get_featuredata(df_toharmonize)\n",
    "\n",
    "# # Perform PCA\n",
    "# pca = PCA(n_components=20)\n",
    "# pca.fit(training_data)\n",
    "# pca_embedding = pca.transform(training_data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Added Metadata_Z, Metadata_Spheroid_ID, and Metadata_Radial_Distance_3D\n",
      "3D Radial distance range: 0.1 - 205.1 µm\n",
      "\n",
      "Equatorial Z-planes by spheroid:\n",
      "Metadata_Spheroid_ID\n",
      "PB000137_B02     8\n",
      "PB000137_B04    10\n",
      "PB000137_B05    10\n",
      "PB000137_B06    11\n",
      "PB000137_B08    11\n",
      "Name: Metadata_Equatorial_Z, dtype: int64\n"
     ]
    }
   ],
   "source": [
    "# Extract z-plane from filename and create spheroid ID\n",
    "DataSingleCell['Metadata_Z'] = DataSingleCell['FileName_CONC_cytoplasm'].str.extract(r'-z(\\d+)-')[0].astype(int)\n",
    "DataSingleCell['Metadata_Spheroid_ID'] = (DataSingleCell['Metadata_Barcode'].astype(str) + '_' + \n",
    "                                           DataSingleCell['Metadata_Well'].astype(str)\n",
    ")\n",
    "\n",
    "# Calculate 3D radial distance from equatorial plane center (Hybrid Method)\n",
    "def calc_radial_distance_3d(df, pixel_size=0.227, z_step=5.0):\n",
    "    \"\"\"\n",
    "    Calculate 3D radial distance from equatorial plane center for each cell.\n",
    "    \n",
    "    Args:\n",
    "        df: DataFrame with single cell data\n",
    "        pixel_size: Pixel size in microns (default: 0.227 µm/pixel)\n",
    "        z_step: Z-step size in microns (default: 5.0 µm)\n",
    "    \n",
    "    Returns:\n",
    "        DataFrame with Metadata_Radial_Distance_3D in microns\n",
    "    \"\"\"\n",
    "    centers = []\n",
    "    for sph_id, sph_data in df.groupby('Metadata_Spheroid_ID'):\n",
    "        # Find equatorial plane (largest radial extent)\n",
    "        max_radius, center_x, center_y, center_z = 0, None, None, None\n",
    "        for z, z_data in sph_data.groupby('Metadata_Z'):\n",
    "            cx, cy = z_data['Location_Center_X_cytoplasm'].mean(), z_data['Location_Center_Y_cytoplasm'].mean()\n",
    "            r_max = np.sqrt((z_data['Location_Center_X_cytoplasm'] - cx)**2 + \n",
    "                           (z_data['Location_Center_Y_cytoplasm'] - cy)**2).max()\n",
    "            if r_max > max_radius:\n",
    "                max_radius, center_x, center_y, center_z = r_max, cx, cy, z\n",
    "        centers.append({'Metadata_Spheroid_ID': sph_id, 'Center_X': center_x, \n",
    "                       'Center_Y': center_y, 'Center_Z': center_z})\n",
    "    \n",
    "    # Merge centers and calculate 3D radial distance in microns\n",
    "    centers_df = pd.DataFrame(centers)\n",
    "    df = df.merge(centers_df, on='Metadata_Spheroid_ID', how='left')\n",
    "    \n",
    "    # Convert to microns and calculate 3D distance\n",
    "    x_um = (df['Location_Center_X_cytoplasm'] - df['Center_X']) * pixel_size\n",
    "    y_um = (df['Location_Center_Y_cytoplasm'] - df['Center_Y']) * pixel_size\n",
    "    z_um = (df['Metadata_Z'] - df['Center_Z']) * z_step\n",
    "    \n",
    "    df['Metadata_Radial_Distance_3D'] = np.sqrt(x_um**2 + y_um**2 + z_um**2)\n",
    "    df['Metadata_Equatorial_Z'] = df['Center_Z']\n",
    "    \n",
    "    return df.drop(columns=['Center_X', 'Center_Y', 'Center_Z'])\n",
    "\n",
    "DataSingleCell = calc_radial_distance_3d(DataSingleCell)\n",
    "print(f\"Added Metadata_Z, Metadata_Spheroid_ID, and Metadata_Radial_Distance_3D\")\n",
    "print(f\"3D Radial distance range: {DataSingleCell['Metadata_Radial_Distance_3D'].min():.1f} - {DataSingleCell['Metadata_Radial_Distance_3D'].max():.1f} µm\")\n",
    "print(f\"\\nEquatorial Z-planes by spheroid:\")\n",
    "print(DataSingleCell.groupby('Metadata_Spheroid_ID')['Metadata_Equatorial_Z'].first().head())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12])"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Check unique z planes\n",
    "DataSingleCell['Metadata_Z'].unique()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Visualize a sample spheroid in 3D colored by 3D radial distance\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "sample_sph = DataSingleCell['Metadata_Spheroid_ID'].iloc[1]\n",
    "sample_data = DataSingleCell[DataSingleCell['Metadata_Spheroid_ID'] == sample_sph]\n",
    "\n",
    "fig = plt.figure(figsize=(10, 8))\n",
    "ax = fig.add_subplot(111, projection='3d')\n",
    "\n",
    "# Plot all cells colored by radial distance\n",
    "scatter = ax.scatter(sample_data['Location_Center_X_cytoplasm'], \n",
    "                     sample_data['Location_Center_Y_cytoplasm'],\n",
    "                     sample_data['Metadata_Z'],\n",
    "                     c=sample_data['Metadata_Radial_Distance_3D'],\n",
    "                     cmap='viridis', s=10, alpha=0.6)\n",
    "\n",
    "# Get equatorial plane and center coordinates for this spheroid\n",
    "eq_z = sample_data['Metadata_Equatorial_Z'].iloc[0]\n",
    "eq_plane_data = sample_data[sample_data['Metadata_Z'] == eq_z]\n",
    "center_x = eq_plane_data['Location_Center_X_cytoplasm'].mean()\n",
    "center_y = eq_plane_data['Location_Center_Y_cytoplasm'].mean()\n",
    "\n",
    "# Mark the center point\n",
    "ax.scatter([center_x], [center_y], [eq_z], \n",
    "          c='red', s=200, marker='*', edgecolors='black', linewidths=2,\n",
    "          label=f'Center (Z={eq_z})')\n",
    "\n",
    "# Flip Z axis (plane 12 at bottom)\n",
    "ax.invert_zaxis()\n",
    "\n",
    "# Set viewing angle (can adjust elev and azim for different perspectives)\n",
    "ax.view_init(elev=20, azim=45)\n",
    "\n",
    "ax.set_xlabel('X (pixels)')\n",
    "ax.set_ylabel('Y (pixels)')\n",
    "ax.set_zlabel('Z plane')\n",
    "ax.set_title(f'Spheroid {sample_sph}\\nColored by 3D Radial Distance')\n",
    "ax.legend()\n",
    "plt.colorbar(scatter, label='3D Radial Distance (µm)', shrink=0.5)\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "print(f\"Equatorial plane: Z = {eq_z}\")\n",
    "print(f\"Center coordinates: X={center_x:.1f}, Y={center_y:.1f}, Z={eq_z}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Convert to AnnData format"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import anndata as ad\n",
    "\n",
    "def convert_to_anndata(df, pixel_size=0.227, z_step=5.0):\n",
    "    \"\"\"\n",
    "    Convert CellProfiler DataFrame to AnnData format.\n",
    "    \n",
    "    Args:\n",
    "        df: DataFrame with single cell data (features + metadata)\n",
    "        pixel_size: Pixel size in microns\n",
    "        z_step: Z-step size in microns\n",
    "    \n",
    "    Returns:\n",
    "        AnnData object with proper organization\n",
    "    \"\"\"\n",
    "    \n",
    "    # 1. Separate columns by type\n",
    "    # Metadata columns (categorical/descriptive)\n",
    "    metadata_cols = [c for c in df.columns if c.startswith('Metadata_') or \n",
    "                     c.startswith('FileName_') or c.startswith('PathName_')]\n",
    "    \n",
    "    # Spatial location columns (will go to .obsm)\n",
    "    location_cols = [c for c in df.columns if 'Location_Center' in c]\n",
    "    \n",
    "    # Object tracking columns (will go to .obs as identifiers)\n",
    "    identifier_cols = [c for c in df.columns if c.startswith('ImageNumber_') or \n",
    "                      c.startswith('ObjectNumber_')]\n",
    "    \n",
    "    # Feature columns (everything else = morphological measurements)\n",
    "    exclude_cols = metadata_cols + location_cols + identifier_cols\n",
    "    feature_cols = [c for c in df.columns if c not in exclude_cols]\n",
    "    \n",
    "    print(f\"Column breakdown:\")\n",
    "    print(f\"  Metadata: {len(metadata_cols)}\")\n",
    "    print(f\"  Location: {len(location_cols)}\")\n",
    "    print(f\"  Identifiers: {len(identifier_cols)}\")\n",
    "    print(f\"  Features: {len(feature_cols)}\")\n",
    "    \n",
    "    # 2. Create the main feature matrix (X)\n",
    "    X = df[feature_cols].values\n",
    "    \n",
    "    # 3. Create .obs (cell-level metadata)\n",
    "    obs = df[metadata_cols + identifier_cols].copy()\n",
    "    obs.index = obs.index.astype(str)  # AnnData requires string indices\n",
    "    \n",
    "    # 4. Create .var (feature-level metadata)\n",
    "    var = pd.DataFrame(index=feature_cols)\n",
    "    \n",
    "    # Parse feature information from column names\n",
    "    # Example: \"Intensity_MeanIntensity_HOECHST_nucleus\" -> \n",
    "    #   measurement_type: Intensity, metric: MeanIntensity, channel: HOECHST, compartment: nucleus\n",
    "    def parse_feature_name(name):\n",
    "        parts = name.split('_')\n",
    "        info = {\n",
    "            'measurement_type': parts[0] if len(parts) > 0 else 'unknown',\n",
    "            'compartment': parts[-1] if len(parts) > 0 else 'unknown',\n",
    "            'channel': None,\n",
    "            'metric': None\n",
    "        }\n",
    "        \n",
    "        # Try to extract channel (common channels: HOECHST, MITO, SYTO, PHAandWGA, CONC)\n",
    "        channels = ['HOECHST', 'MITO', 'SYTO', 'PHAandWGA', 'CONC']\n",
    "        for channel in channels:\n",
    "            if channel in name:\n",
    "                info['channel'] = channel\n",
    "                break\n",
    "        \n",
    "        # Extract metric (e.g., MeanIntensity, MaxIntensity, Area, etc.)\n",
    "        if len(parts) > 1:\n",
    "            info['metric'] = parts[1]\n",
    "        \n",
    "        return pd.Series(info)\n",
    "    \n",
    "    var_info = pd.DataFrame([parse_feature_name(name) for name in feature_cols], index=feature_cols)\n",
    "    var = pd.concat([var, var_info], axis=1)\n",
    "    \n",
    "    # 5. Create .obsm (multi-dimensional annotations)\n",
    "    obsm = {}\n",
    "    \n",
    "    # 3D spatial coordinates (pixels)\n",
    "    if 'Location_Center_X_cytoplasm' in df.columns and 'Metadata_Z' in df.columns:\n",
    "        spatial_3d = np.column_stack([\n",
    "            df['Location_Center_X_cytoplasm'].values,\n",
    "            df['Location_Center_Y_cytoplasm'].values,\n",
    "            df['Metadata_Z'].values\n",
    "        ])\n",
    "        obsm['spatial_3d'] = spatial_3d\n",
    "        \n",
    "        # Also create 2D coordinates (X, Y only)\n",
    "        obsm['spatial_2d'] = spatial_3d[:, :2]\n",
    "    \n",
    "    # 6. Create .uns (unstructured metadata)\n",
    "    uns = {\n",
    "        'pixel_size_um': pixel_size,\n",
    "        'z_step_um': z_step,\n",
    "        'dataset': 'HCT116',\n",
    "        'n_z_planes': len(df['Metadata_Z'].unique()) if 'Metadata_Z' in df.columns else None,\n",
    "        'n_spheroids': len(df['Metadata_Spheroid_ID'].unique()) if 'Metadata_Spheroid_ID' in df.columns else None,\n",
    "    }\n",
    "    \n",
    "    # Store spheroid centers if available\n",
    "    if 'Metadata_Spheroid_ID' in df.columns and 'Metadata_Equatorial_Z' in df.columns:\n",
    "        centers = {}\n",
    "        for sph_id in df['Metadata_Spheroid_ID'].unique():\n",
    "            sph_data = df[df['Metadata_Spheroid_ID'] == sph_id]\n",
    "            eq_z = sph_data['Metadata_Equatorial_Z'].iloc[0]\n",
    "            eq_plane = sph_data[sph_data['Metadata_Z'] == eq_z]\n",
    "            centers[sph_id] = {\n",
    "                'center_x': eq_plane['Location_Center_X_cytoplasm'].mean(),\n",
    "                'center_y': eq_plane['Location_Center_Y_cytoplasm'].mean(),\n",
    "                'center_z': eq_z\n",
    "            }\n",
    "        uns['spheroid_centers'] = centers\n",
    "    \n",
    "    # 7. Create AnnData object\n",
    "    adata = ad.AnnData(X=X, obs=obs, var=var, obsm=obsm, uns=uns)\n",
    "    \n",
    "    print(f\"\\nAnnData object created:\")\n",
    "    print(f\"  Shape: {adata.shape} (cells × features)\")\n",
    "    print(f\"  .obs columns: {adata.obs.shape[1]}\")\n",
    "    print(f\"  .var columns: {adata.var.shape[1]}\")\n",
    "    print(f\"  .obsm keys: {list(adata.obsm.keys())}\")\n",
    "    print(f\"  .uns keys: {list(adata.uns.keys())}\")\n",
    "    \n",
    "    return adata\n",
    "\n",
    "# Convert to AnnData\n",
    "adata = convert_to_anndata(DataSingleCell, pixel_size=0.227, z_step=5.0)\n",
    "adata"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Quick sanity checks and example usage\n",
    "print(\"=== SANITY CHECKS ===\\n\")\n",
    "\n",
    "# Check that we can filter by spheroid\n",
    "print(\"1. Filter cells from one spheroid:\")\n",
    "spheroid_id = adata.obs['Metadata_Spheroid_ID'].iloc[0]\n",
    "spheroid_cells = adata[adata.obs['Metadata_Spheroid_ID'] == spheroid_id]\n",
    "print(f\"   Spheroid {spheroid_id}: {spheroid_cells.n_obs} cells\\n\")\n",
    "\n",
    "# Check that we can access spatial coordinates\n",
    "print(\"2. Access 3D spatial coordinates:\")\n",
    "xyz = adata.obsm['spatial_3d']\n",
    "print(f\"   Shape: {xyz.shape}\")\n",
    "print(f\"   X range: {xyz[:, 0].min():.1f} - {xyz[:, 0].max():.1f} pixels\")\n",
    "print(f\"   Y range: {xyz[:, 1].min():.1f} - {xyz[:, 1].max():.1f} pixels\")\n",
    "print(f\"   Z range: {xyz[:, 2].min():.0f} - {xyz[:, 2].max():.0f} planes\\n\")\n",
    "\n",
    "# Check radial distance distribution\n",
    "print(\"3. Radial distance distribution:\")\n",
    "rad_dist = adata.obs['Metadata_Radial_Distance_3D']\n",
    "print(f\"   Min: {rad_dist.min():.1f} µm\")\n",
    "print(f\"   Median: {rad_dist.median():.1f} µm\")\n",
    "print(f\"   Max: {rad_dist.max():.1f} µm\\n\")\n",
    "\n",
    "# Check feature categories\n",
    "print(\"4. Feature measurement types:\")\n",
    "print(adata.var['measurement_type'].value_counts())"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": ".venv",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
